<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Task7 02-july</title>
   </head>
   <body>
      <h2>1. Try Catch</h2>
      <h2>2. Throwing our own errors using throw</h2>
      <h2>3. try…catch…finally</h2>
      <h2>4. Extending Error</h2>
      <h2>5. Further inheritance</h2>
      <h2>6. Wrapping exceptions</h2>
      <h2>7. Callback</h2>
      <h2>8. Handling errors</h2>
      <h2>9. Promise</h2>
      <h2>10. Generator functions</h2>
      <h2>11. Generator composition</h2>
      <h2>12. “yield” is a two-way street</h2>
      <h2>13. generator.throw</h2>
      <h2>14. generator.return</h2>
      <h2>15. Async iteration and generators</h2>
      <h2>16. Recall generators</h2>
      <h2>17. Async generators (finally)</h2>
      <h2>18. Real-life example: paginated data</h2>
      <script>
         // 1. try catch
         // try {
         //    alert('Start of try runs') // (1) <--

         //    lalala // error, variable is not defined!

         //    alert('End of try (never reached)') // (2)
         // } catch (err) {
         //    alert(`Error has occurred!`) // (3) <--
         // }

         /**/
         // try {
         //    lalala
         // } catch (err) {
         //    alert(err.name)
         //    alert(err.message)
         //    alert(err.stack)
         //    alert(err)
         // }

         // 2. Throwing our own errors using throw
         // let json = '{ "age": 30 }' // incomplete data

         // try {
         //    let user = JSON.parse(json) // <-- no errors

         //    if (!user.name) {
         //       throw new Error('Incomplete data: no name') // (*)
         //    }

         //    alert(user.name)
         // } catch (err) {
         //    alert('JSON Error: ' + err.message) // JSON Error: Incomplete data: no name
         // }

         // 3. try…catch…finally
         // try {
         //    alert('try')
         //    if (confirm('Make an error?')) BAD_CODE()
         // } catch (err) {
         //    alert('catch')
         // } finally {
         //    alert('finally')
         // }

         /* */

         // let num = +prompt('Enter a positive integer number?', 35)

         // let diff, result

         // function fib(n) {
         //    if (n < 0 || Math.trunc(n) != n) {
         //       throw new Error('Must not be negative, and also an integer.')
         //    }
         //    return n <= 1 ? n : fib(n - 1) + fib(n - 2)
         // }

         // let start = Date.now()

         // try {
         //    result = fib(num)
         // } catch (err) {
         //    result = 0
         // } finally {
         //    diff = Date.now() - start
         // }

         // alert(result || 'error occurred')

         // alert(`execution took ${diff}ms`)

         // 4. Extending Error
         // class ValidationError extends Error {
         //    constructor(message) {
         //       super(message) // (1)
         //       this.name = 'ValidationError' // (2)
         //    }
         // }

         // function test() {
         //    throw new ValidationError('Whoops!')
         // }

         // try {
         //    test()
         // } catch (err) {
         //    alert(err.message) // Whoops!
         //    alert(err.name) // ValidationError
         //    alert(err.stack) // a list of nested calls with line numbers for each
         // }

         /* */
         // class ValidationError extends Error {
         //    constructor(message) {
         //       super(message)
         //       this.name = 'ValidationError'
         //    }
         // }

         // // Usage
         // function readUser(json) {
         //    let user = JSON.parse(json)

         //    if (!user.age) {
         //       throw new ValidationError('No field: age')
         //    }
         //    if (!user.name) {
         //       throw new ValidationError('No field: name')
         //    }

         //    return user
         // }

         // // Working example with try..catch

         // try {
         //    let user = readUser('{ "age": 25 }')
         // } catch (err) {
         //    if (err instanceof ValidationError) {
         //       alert('Invalid data: ' + err.message) // Invalid data: No field: name
         //    } else if (err instanceof SyntaxError) {
         //       // (*)
         //       alert('JSON Syntax Error: ' + err.message)
         //    } else {
         //       throw err // unknown error, rethrow it (**)
         //    }
         // }

         // 5. Further inheritance
         // class ValidationError extends Error {
         //    constructor(message) {
         //       super(message)
         //       this.name = 'ValidationError'
         //    }
         // }
         // class PropertyRequiredError extends ValidationError {
         //    constructor(property) {
         //       super('No property: ' + property)
         //       this.name = 'PropertyRequiredError'
         //       this.property = property
         //    }
         // }
         // // Usage
         // function readUser(json) {
         //    let user = JSON.parse(json)

         //    if (!user.age) {
         //       throw new PropertyRequiredError('age')
         //    }
         //    if (!user.name) {
         //       throw new PropertyRequiredError('name')
         //    }

         //    return user
         // }
         // // Working example with try..catch
         // try {
         //    let user = readUser('{ "age": 25 }')
         // } catch (err) {
         //    if (err instanceof ValidationError) {
         //       alert('Invalid data: ' + err.message) // Invalid data: No property: name
         //       alert(err.name) // PropertyRequiredError
         //       alert(err.property) // name
         //    } else if (err instanceof SyntaxError) {
         //       alert('JSON Syntax Error: ' + err.message)
         //    } else {
         //       throw err // unknown error, rethrow it
         //    }
         // }

         // 6. Wrapping exceptions
         // class ReadError extends Error {
         //    constructor(message, cause) {
         //       super(message)
         //       this.cause = cause
         //       this.name = 'ReadError'
         //    }
         // }

         // class ValidationError extends Error {
         //    constructor(message, cause) {
         //       super(message)
         //       this.cause = cause
         //       this.name = 'ValidationError'
         //    }
         // }
         // class PropertyRequiredError extends ValidationError {
         //    constructor(message, cause) {
         //       super(message)
         //       this.cause = cause
         //       this.name = 'PropertyRequiredError'
         //    }
         // }

         // function validateUser(user) {
         //    if (!user.age) {
         //       throw new PropertyRequiredError('age')
         //    }

         //    if (!user.name) {
         //       throw new PropertyRequiredError('name')
         //    }
         // }

         // function readUser(json) {
         //    let user

         //    try {
         //       user = JSON.parse(json)
         //    } catch (err) {
         //       if (err instanceof SyntaxError) {
         //          throw new ReadError('Syntax Error', err)
         //       } else {
         //          throw err
         //       }
         //    }

         //    try {
         //       validateUser(user)
         //    } catch (err) {
         //       if (err instanceof ValidationError) {
         //          throw new ReadError('Validation Error', err)
         //       } else {
         //          throw err
         //       }
         //    }
         // }

         // try {
         //    readUser('{bad json}')
         // } catch (e) {
         //    if (e instanceof ReadError) {
         //       alert(e)
         //       // Original error: SyntaxError: Unexpected token b in JSON at position 1
         //       alert('Original error: ' + e.cause)
         //    } else {
         //       throw e
         //    }
         // }

         // 7. Callback
         // function loadScript(src, callback) {
         //    let script = document.createElement('script')
         //    script.src = src
         //    script.onload = () => callback(script)
         //    document.head.append(script)
         // }

         // loadScript(
         //    'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js',
         //    (script) => {
         //       alert(`Cool, the script ${script.src} is loaded`)
         //       alert(_) // function declared in the loaded script
         //    }
         // )

         // 8. Handling errors
         // function loadScript(src, callback) {
         //    let script = document.createElement('script')
         //    script.src = src

         //    script.onload = () => callback(null, script)
         //    script.onerror = () =>
         //       callback(new Error(`Script load error for ${src}`))

         //    document.head.append(script)
         // }

         // 9. Promise
         // let promise = new Promise(function (resolve, reject) {
         //    // not taking our time to do the job
         //    resolve(123) // immediately give the result: 123
         // })

         // 10. Generator functions
         // function* generateSequence() {
         //    yield 1
         //    yield 2
         //    // return 3
         //    yield 3
         // }

         // let generator = generateSequence()

         // let one = generator.next()
         // let two = generator.next()
         // let three = generator.next()
         // alert(JSON.stringify(one))
         // alert(JSON.stringify(two))
         // alert(JSON.stringify(three))

         /* */
         // for (let value of generator) {
         //    alert(value)
         // }

         /* */

         // let sequence = [0, ...generateSequence()]

         // alert(sequence)

         // 11.Generator composition
         // function* generateSequence(start, end) {
         //    for (let i = start; i <= end; i++) yield i
         // }
         // function* generatePasswordCodes() {
         //    // 0..9
         //    yield* generateSequence(48, 57)

         //    // A..Z
         //    yield* generateSequence(65, 90)

         //    // a..z
         //    yield* generateSequence(97, 122)
         // }

         // let str = ''

         // for (let code of generatePasswordCodes()) {
         //    str += String.fromCharCode(code)
         // }
         // alert(str)

         // 12. “yield” is a two-way street
         // function* gen() {
         //    // Pass a question to the outer code and wait for an answer
         //    let result = yield '2 + 2 = ?' // (*)

         //    alert(result)
         // }

         // let generator = gen()

         // let question = generator.next().value // <-- yield returns the value

         // generator.next(4)

         // function* gen() {
         //    let ask1 = yield '2 + 2 = ?'
         //    alert(ask1) // 4
         //    let ask2 = yield '3 * 3 = ?'
         //    alert(ask2) // 9
         // }
         // let generator = gen()
         // alert(generator.next().value) // "2 + 2 = ?"
         // alert(generator.next(4).value) // "3 * 3 = ?"
         // alert(generator.next(9).done)

         // 13. generator.throw
         // function* gen() {
         //    try {
         //       let result = yield '2 + 2 = ?' // (1)

         //       alert(
         //          'The execution does not reach here, because the exception is thrown above'
         //       )
         //    } catch (e) {
         //       alert(e) // shows the error
         //    }
         // }
         // let generator = gen()
         // let question = generator.next().value
         // generator.throw(new Error('The answer is not found in my database'))

         /* */
         // function* generate() {
         //    let result = yield '2 + 2 = ?' // Error in this line
         // }

         // let generator = generate()

         // let question = generator.next().value

         // try {
         //    generator.throw(new Error('The answer is not found in my database'))
         // } catch (e) {
         //    alert(e) // shows the error
         // }

         // 14. generator.return
         // function* gen() {
         //    yield 1
         //    yield 2
         //    yield 3
         // }

         // const g = gen()

         // g.next()
         // g.return('foo')
         // g.next()

         // 15. Async iteration and generators
         // let range = {
         //    from: 1,
         //    to: 5,

         //    [Symbol.asyncIterator]() {
         //       // (1)
         //       return {
         //          current: this.from,
         //          last: this.to,

         //          async next() {
         //             // (2)

         //             // note: we can use "await" inside the async next:
         //             await new Promise((resolve) => setTimeout(resolve, 1000)) // (3)

         //             if (this.current <= this.last) {
         //                return { done: false, value: this.current++ }
         //             } else {
         //                return { done: true }
         //             }
         //          }
         //       }
         //    }
         // }

         // ;(async () => {
         //    for await (let value of range) {
         //       // (4)
         //       alert(value) // 1,2,3,4,5
         //    }
         // })()

         // 16. Recall generators
         // function* generateSequence(start, end) {
         //    for (let i = start; i <= end; i++) {
         //       yield i
         //    }
         // }

         // for (let value of generateSequence(1, 5)) {
         //    alert(value) // 1, then 2, then 3, then 4, then 5
         // }

         // 17. Async generators (finally)
         // async function* generateSequence(start, end) {
         //    for (let i = start; i <= end; i++) {
         //       // Wow, can use await!
         //       await new Promise((resolve) => setTimeout(resolve, 1000))

         //       yield i
         //    }
         // }

         // ;(async () => {
         //    let generator = generateSequence(1, 5)
         //    for await (let value of generator) {
         //       alert(value) // 1, then 2, then 3, then 4, then 5 (with delay between)
         //    }
         // })()

         // 18. Real-life example: paginated data
         async function* fetchCommits(repo) {
            let url = `https://api.github.com/repos/${repo}/commits`

            while (url) {
               const response = await fetch(url, {
                  // (1)
                  headers: { 'User-Agent': 'Our script' } // github needs any user-agent header
               })

               const body = await response.json() // (2) response is JSON (array of commits)

               // (3) the URL of the next page is in the headers, extract it
               let nextPage = response.headers
                  .get('Link')
                  .match(/<(.*?)>; rel="next"/)
               nextPage = nextPage?.[1]

               url = nextPage

               for (let commit of body) {
                  // (4) yield commits one by one, until the page ends
                  yield commit
               }
            }
         }
         // console.log('Hello')
      </script>
   </body>
</html>
